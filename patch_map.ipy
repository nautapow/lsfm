import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from scipy import signal,stats
import TFTool
import tone
import pandas as pd
import itertools
from lsfm_psth import Psth
import math
import regression


%matplotlib inline
df = pd.read_csv('patch_list_E.csv', dtype={'date':str, '#':str})
idx_tone = df.index[(df['type']=='Pure Tones') & (df['project']!='Vc') & (df['hard_exclude']!='exclude')]
idx_tone = [i for i in idx_tone if i > 146]
idx_lsfm = df.index[(df['type']=='Log sFM') & (df['project']!='Vc') & (df['hard_exclude']!='exclude')]
idx_lsfm = [i for i in idx_lsfm if i > 146]
jitter = pd.read_csv('jitter.csv')

# =============================================================================
# #region = [x0:x3], [y0:y3], [x_err1:x_err3], [y_err1:yerr3]
# region = [[0, 1.0, 0.0, 1.029], [0, 0.0, 0.926, 0.726], [0.02, 0.02, 0.02, 0.203], [0.04, 0.04, 0.223, 0.166]]
# region_4p = [[0, 0.548, 0.548, 1.0], [0, -0.379, 0.471, 0.0], [0.02, 0.059, 0.059, 0.02], [0.02, 0.123, 0.094, 0.02]]
# =============================================================================
#A1AAF 
#region = [-0.54788889, 0, 0, 0.45211111], [0, 0.44133333, -0.55866667, 0], [0.01420644, 0, 0, 0.01420644], [0, 0.02509863, 0.02509863, 0]
#A1A2 - mid
region = [-0.5, -0.213, 0.5, 0.606], [0, 1.086, 0, 1.086], [0, 0.042, 0, 0.053], [0, 0.059, 0, 0.053]

"""analysis type"""
saveplot=False


get_region = False
map_bf = False
tone_analysis = False
lsfm_analysis = True
intrisic_analysis = False
spike_analysis = False

        
        
      
# =============================================================================
# if map_bf:
#     coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
#     df2 = pd.read_csv('patch_list_with_bf.csv', dtype={'date':str, '#':str})
#     idx = df2.index[(df2['type']=='Pure Tones') & (df2['project']=='Ic_map') & (df2['hard_exclude']!='exclude')]
#     
#     patch_x, patch_y = [],[]
#     bf = []
#     for i in idx:
#         mouseID = df2.iloc[i]['mouse_id']
#         site = f'Patch_{df2.iloc[i]["site"]}'
#  
#         patch_x.append(coords[(coords['mouseid'] == mouseID) & (coords['regions'] == site)].x_A12.item())
#         patch_y.append(coords[(coords['mouseid'] == mouseID) & (coords['regions'] == site)].y_A12.item())
#         bf.append(df2.iloc[i].best_frequency.item())
#     
#     bf_k = np.array([i/1000 for i in bf])
#     patch_x = np.array(patch_x)
#     patch_y = np.array(patch_y)
#     
#     fig, ax = plt.subplots()
#     ax.scatter(region[0], region[1], c='black', s=500)
#     im = ax.scatter(patch_x+np.random.normal(0, .03, patch_x.size), patch_y+np.random.normal(0, .03, patch_y.size), c=bf_k, cmap='inferno') 
# 
#     plt.title('bf_map')
#     plt.savefig('bf_map.png', dpi=500)
# =============================================================================


def detect_outliers(arr):
    from scipy.special import erfcinv
    arr = np.array(arr)
    
    # --- IQR Method ---
    q1 = np.percentile(arr, 25)
    q3 = np.percentile(arr, 75)
    iqr = q3 - q1
    lower_iqr = q1 - 1.5 * iqr
    upper_iqr = q3 + 1.5 * iqr
    iqr_mask = (arr < lower_iqr) | (arr > upper_iqr)

    # --- MAD Method ---
    median = np.median(arr)
    mad = np.median(np.abs(arr - median))
    c = -1 / (np.sqrt(2) * erfcinv(3/2))  # scale constant
    scaled_mad = c * mad
    mad_mask = np.abs(arr - median) > 3 * scaled_mad

    # --- Combined: Only mark as outlier if both methods agree ---
    combined_mask = iqr_mask & mad_mask
    return combined_mask


from collections import defaultdict

def compute_radial_spread_coords(x_list, y_list, ids, radius=0.05):
    """
    Generate radiating coordinates for overlapping IDs.
    Returns scattered x/y coords and a list of lines from center to each point.
    """
    from collections import defaultdict
    import numpy as np

    coord_dict = defaultdict(list)
    for i, key in enumerate(ids):
        coord_dict[key].append(i)

    xs, ys = np.array(x_list), np.array(y_list)
    out_x, out_y = np.copy(xs), np.copy(ys)
    lines = []

    for key, indices in coord_dict.items():
        n = len(indices)
        if n > 1:
            center_x = xs[indices[0]]
            center_y = ys[indices[0]]
            angles = np.linspace(0, 2*np.pi, n, endpoint=False)
            for angle, idx in zip(angles, indices):
                dx = radius * np.cos(angle)
                dy = radius * np.sin(angle)
                out_x[idx] += dx
                out_y[idx] += dy
                lines.append((center_x, center_y, out_x[idx], out_y[idx]))
    
    return out_x, out_y, lines

def plot_map(patch_x, patch_y, arr, ids, region=region, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    from matplotlib import patches, colors

    arr = np.array(arr)
    patch_x, patch_y = np.array(patch_x), np.array(patch_y)

    # New: Get radiated coordinates and center-line segments
    scatter_x, scatter_y, center_lines = compute_radial_spread_coords(patch_x, patch_y, ids, radius=0.05)

    region_xy = list(zip(region[0], region[1]))

    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    cmap = kwargs.get('cmap', 'inferno')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')
    diverge = kwargs.get('diverge', False)

    norm = colors.CenteredNorm() if diverge else None
    if diverge:
        cmap = 'RdYlBu_r'

    fig, ax = plt.subplots()

    # Draw region ovals
    for i in range(len(region_xy)):
        ellipse = patches.Ellipse(region_xy[i], 0.05, 0.05, angle=0, color='grey', alpha=0.9)
        ax.add_patch(ellipse)

    # New: Draw dashed lines from patch center to each radiated point
    for x0, y0, x1, y1 in center_lines:
        ax.plot([x0, x1], [y0, y1], linestyle='dashed', color='gray', alpha=0.6, linewidth=1)

    # Scatter plot
    if outlier_mask is not None:
        inliers = ~outlier_mask
        outliers = outlier_mask
        sc = ax.scatter(scatter_x[inliers], scatter_y[inliers], c=arr[inliers], cmap=cmap,
                        s=120, alpha=0.9, vmin=vmin, vmax=vmax, norm=norm)
        ax.scatter(scatter_x[outliers], scatter_y[outliers], c='gray', s=120, alpha=0.5, label='Outlier')
    else:
        sc = ax.scatter(scatter_x, scatter_y, c=arr, cmap=cmap,
                        s=120, alpha=0.9, vmin=vmin, vmax=vmax, norm=norm)

    # Colorbar
    cbar = fig.colorbar(sc, ax=ax)
    cbar.ax.set_ylabel(ylabel, fontsize=16)

    ax.set_xlabel('A1 low – A2 high', fontsize=16)
    ax.set_ylabel('A1–A2 orthogonal', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)
    ax.legend()

    if saveplot:
        plt.savefig(f'{title}_map.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()


def plot_ortho_xx(ortho_x, arr, fit, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    import numpy as np

    ortho_x, arr = np.array(ortho_x), np.array(arr)
    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')

    fig, ax = plt.subplots()

    if outlier_mask is not None:
        inliers = ~outlier_mask
        ax.scatter(ortho_x[inliers], arr[inliers], s=50, alpha=0.7, color='blue')
        ax.scatter(ortho_x[outlier_mask], arr[outlier_mask], s=50, alpha=0.5, color='gray', label='Outlier')
    else:
        ax.scatter(ortho_x, arr, s=50, alpha=0.7)

    ax.plot(fit[0], fit[1], color='red', label='Fit')
    ax.annotate(f'$R^2$: {fit[2]:.2f}', xy=(0.99, 0.97), xycoords='axes fraction', size=14, ha='right', va='top')
    ax.annotate(f'P = {float(fit[3]):.3g}', xy=(0.99, 0.90), xycoords='axes fraction', size=14, ha='right', va='top')

    ax.set_ylabel(ylabel, fontsize=16)
    ax.set_xlabel('X-axis projection', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)

    if vmin is not None and vmax is not None:
        ax.set_ylim(vmin, vmax)

    ax.legend()

    if saveplot:
        plt.savefig(f'{title}_orthoX.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()
    
def plot_ortho_yy(ortho_y, arr, fit, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    import numpy as np

    ortho_y, arr = np.array(ortho_y), np.array(arr)
    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')

    fig, ax = plt.subplots()

    if outlier_mask is not None:
        inliers = ~outlier_mask
        ax.scatter(ortho_y[inliers], arr[inliers], s=50, alpha=0.7, color='blue')
        ax.scatter(ortho_y[outlier_mask], arr[outlier_mask], s=50, alpha=0.5, color='gray', label='Outlier')
    else:
        ax.scatter(ortho_y, arr, s=50, alpha=0.7)

    ax.plot(fit[0], fit[1], color='red', label='Fit')
    ax.annotate(f'$R^2$: {fit[2]:.2f}', xy=(0.99, 0.97), xycoords='axes fraction', size=14, ha='right', va='top')
    ax.annotate(f'P = {fit[3]:.3g}', xy=(0.99, 0.90), xycoords='axes fraction', size=14, ha='right', va='top')

    ax.set_ylabel(ylabel, fontsize=16)
    ax.set_xlabel('Y-axis projection', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)

    if vmin is not None and vmax is not None:
        ax.set_ylim(vmin, vmax)

    ax.legend()

    if saveplot:
        plt.savefig(f'{title}_orthoY.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()
    
def check_map(df, x, y, ortho, arr):
    import plotly.io as pio
    import plotly.express as px
    pio.renderers.default='browser'
    
    mouseid = list(df['mouseid'])
    site = list(df['patch_site'])
    filename = list(df['filename']) 
    name = [f'{a[0]}_{a[1]}_{filename[i]}' for i ,a in enumerate(list(zip(mouseid, site)))]
    
    x_dev = np.random.normal(0, .05, len(x))
    fig = px.scatter(x = ortho+x_dev, y = arr, text=name)
    fig.show()
    
    fig = px.scatter(x=x+x_dev, y=y+x_dev, text=name)
    fig.show()

    
    
if map_bf:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    tone_info = pd.read_excel('tone_cell_note.xlsx')
    mouseid = list(tone_info['mouseID'])
    filename = list(tone_info['filename'])
    sites = list(tone_info['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseid):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
        
    
    bf = np.array(list(tone_info['best_frequency']))/1000
    plot_map(patch_x, patch_y, bf, saveplot=True, title='Best_Frequency', ylabel='Best Frequency (kHz)', cmap='viridis')
    #regression.regression_test(ortho, bf)
    fit_orthox = regression.regression_poly(ortho_x, bf, degree=1)
    fit_orthoy = regression.regression_poly(ortho_y, bf, degree=1)
    plot_ortho_xx(ortho_x, bf, fit_orthox, saveplot=True, title='Best_Frequency', ylabel='Best Frequency (kHz)')
    plot_ortho_yy(ortho_y, bf, fit_orthoy, saveplot=True, title='Best_Frequency', ylabel='Best Frequency (kHz)')
    
    #patch = [f'{a}_{b}_{c}' for (a,b,c) in zip(filename, mouseid, sites)]
    patch = [f'{a}_{b}_{c}' for (a,b,c) in zip(filename, mouseid, sites)]
    #plot_map_special(patch_x, patch_y, patch, saveplot=True, title='Patch Map2', ylabel='Patch Map2', data_type='text')
    
    bf_k = np.array([i/1000 for i in bf])
    patch_x = np.array(patch_x)
    patch_y = np.array(patch_y)
    
    fig, ax = plt.subplots()
    ax.scatter(region[0], region[1], c='black', s=500)
    im = ax.scatter(patch_x+np.random.normal(0, .03, patch_x.size), patch_y+np.random.normal(0, .03, patch_y.size), c=bf_k, cmap='inferno')
  
    plt.title('bf_map')
    plt.savefig('bf_map.png', dpi=500)

# =============================================================================
#     #mapping each levels
#     bf_levels = pd.read_excel('tone_para_levels.xlsx', 'bf')
#     band_levels = pd.read_excel('tone_para_levels.xlsx', 'bandwidth')
#     
#     for level in ['40db', '50db', '60db', '70db', '80db']:
#         bfs, bands = [],[]
#         for (ids, names) in zip(mouseid, filename):
#             bfs.append(bf_levels[(bf_levels['mouseID']==ids) & (bf_levels['filename']==names)][level])
#             bands.append(band_levels[(bf_levels['mouseID']==ids) & (bf_levels['filename']==names)][level])
#         
#         bf = np.array(bfs)/1000
#         plot_map(patch_x, patch_y, bf, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)', cmap='viridis')
#         #regression.regression_test(ortho, bf)
#         fit_orthox = regression.regression_poly(ortho_x, bf, degree=1)
#         fit_orthoy = regression.regression_poly(ortho_y, bf, degree=1)
#         plot_ortho_xx(ortho_x, bf, fit_orthox, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)')
#         plot_ortho_yy(ortho_y, bf, fit_orthoy, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)')
# 
#         bandwidth = np.array(bands)
#         plot_map(patch_x, patch_y, bandwidth, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)', cmap='viridis')
#         #regression.regression_test(ortho, bf)
#         fit_orthox = regression.regression_poly(ortho_x, bandwidth, degree=1)
#         fit_orthoy = regression.regression_poly(ortho_y, bandwidth, degree=1)
#         plot_ortho_xx(ortho_x, bandwidth, fit_orthox, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)')
#         plot_ortho_yy(ortho_y, bandwidth, fit_orthoy, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)')
# =============================================================================


if tone_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    tone_psth = pd.read_excel('tone_PSTH_category.xlsx', sheet_name='inband')
    mouseid = list(tone_psth['mouseID'])
    filename = list(tone_psth['filename'])
    sites = list(tone_psth['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseid):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    ids = list(zip(mouseid, sites))
    
    parameters = {
        'bf': ('Best_Frequency', 'Best Frequency (kHz)', 'viridis'),
        'bandwidth': ('Bandwidth', 'Bandwidth (octave)', 'viridis'),
        'peak': ('Peak_Amplitude', 'Peak Amplitude (mV)', 'viridis'),
        'latency': ('Time_to_Peak', 'Time to Peak (ms)', 'viridis'),
        'peri_charge': ('peri_charge', 'Peri-Integration (mV*ms)', 'viridis'),
        'post_charge': ('post_charge', 'Post-Integration (mV*ms)', 'viridis'),
    }

    for key, (title, ylabel, cmap) in parameters.items():
        values = np.array(tone_psth[key])
        if key == 'bf':
            values = values / 1000  # Convert to kHz

        outlier_mask = detect_outliers(values)

        fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
        fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)

        plot_map(patch_x, patch_y, values, ids=ids, saveplot=True, title=title,
                 ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)

        plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)

        plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)
    

if lsfm_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    lsfm_psth_inBF = pd.read_excel('lsfm_PSTH_category.xlsx', sheet_name='inband')
    lsfm_psth_exBF = pd.read_excel('lsfm_PSTH_category.xlsx', sheet_name='exband')
    
    mouseIDs = list(lsfm_psth_inBF['mouseID'])
    sites = list(lsfm_psth_inBF['patch_site'])
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseIDs):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    
    parameters = {
    'onpeak': ('OnPeak_Amplitude', 'Onset Peak Amplitude (mV)', None, None),
    'on_latency': ('Time_to_Peak', 'Time to Onset Peak (ms)', None, None),
    'on_charge': ('Onset_Charge', 'Onset Integrated Polarization (ms*mV)', None, None),
    'sustain': ('Sustain', 'Sustain Potential (mV)', None, None),
    'offpeak': ('OffPeak_Amplitude', 'Offset Peak Amp plateau (mV)', None, None),
    'offpeak_base': ('OffPeak_Amplitude_baseline', 'Offset Peak Amp baseline (mV)', None, None),
    'off_charge': ('Offset_Charge', 'Offset Integrated Polarization (ms*mV)', None, None),
    }

    for condition in ['inband', 'exband']:
        working = lsfm_psth_inBF if condition == 'inband' else lsfm_psth_exBF
        
        for param_key, (title_base, ylabel, vmin, vmax) in parameters.items():
            values = np.array(working[param_key])
            ids = list(zip(mouseIDs, sites))  # use tuple as unique key
            
            # 1. Detect outliers
            outlier_mask = detect_outliers(values)
            
            # 2. Filter for regression (only inliers)
            fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
            fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)
            
            # 3. Plot with highlighting
            plot_map(patch_x, patch_y, values, ids=ids, saveplot=True,
                     title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)
            
            plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                          title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)
            
            plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                          title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)

        
if intrisic_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    intrisic = pd.read_excel('intrinsic_properties.xlsx')
    mouseid = list(intrisic['mouseID'])
    filename = list(intrisic['filename'])
    sites = list(intrisic['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,(m,s) in enumerate(zip(mouseid, sites)):
        site = f'Patch_{s}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    parameters = {
        'resting': ('resting_potential', 'Resting Potential (mV)', 'magma'),
        'spike_rate': ('spike_rate', 'Spike Rate (Hz)', 'magma'),
        'spike_width': ('spike_width', 'Spike Width (ms)', 'magma'),
        'R_all': ('resistance', 'Input Resistance (MΩ)', 'magma'),
        'adaptation': ('adaptation', 'Spike Adaptation (ISI index)', 'magma'),
    }

    for key, (title, ylabel, cmap) in parameters.items():
        values = np.array(intrisic[key])
        ids = list(zip(mouseid, sites))
        
        outlier_mask = detect_outliers(values)

        fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
        fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)

        plot_map(patch_x, patch_y, values, ids=ids, saveplot=True, title=title,
                 ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)

        plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)

        plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)


if spike_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    lsfm_psth_inBF = pd.read_csv('lsfm_psth_para_inBF.csv')
    df_spike = pd.read_csv('spiking_count.csv')
    
    mouseIDs = list(lsfm_psth_inBF['mouseid'])
    sites = list(lsfm_psth_inBF['patch_site'])
    patch_x, patch_y, ortho = [],[],[]
    for i,m in enumerate(mouseIDs):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A1A2.item())
    
    total_spike = list(df_spike['total_spikes'])
    plot_map(patch_x, patch_y, total_spike, saveplot=True, title='Total Spikes', ylabel='Total Spikes (count)', vmax=300)
    
    rate_inbf = list(df_spike['rate_inbf'])
    plot_map(patch_x, patch_y, rate_inbf, saveplot=True, title='Spike Rate, in RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    #regression.regression_test(ortho, rate_inbf)
    fit_x = regression.regression_poly(ortho_x, rate_inbf, degree=1)
    plot_ortho_xx(ortho, rate_inbf, fit_x, saveplot=True, title='Spike Rate, in RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    
    rate_exbf = list(df_spike['rate_exbf'])
    plot_map(patch_x, patch_y, rate_exbf, saveplot=True, title='Spike Rate, out RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    #regression.regression_test(ortho, rate_exbf)
    fit_x = regression.regression_poly(ortho_x, rate_exbf, degree=1)
    plot_ortho_xx(ortho_x, rate_exbf, fit_x, saveplot=True, title='Spike Rate, out RF', ylabel='Spikes/Stimulus (count)', vmax=2)




