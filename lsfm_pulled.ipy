import numpy as np
import os
import matplotlib.pyplot as plt
import matplotlib as mpl
%matplotlib inline
from pathlib import Path
from scipy import signal
from scipy import stats
from scipy import interpolate
import scipy.io
import TFTool
import pandas as pd
import lsfm
import lsfm_psth
from lsfm_psth import Psth


df = pd.read_csv('patch_list_E.csv', dtype={'date':str, '#':str})
infos = pd.read_excel('lsfm_cell_note.xlsx')
df_cursor_in = pd.read_excel('lsfm_PSTH_cursors.xlsx', sheet_name='in_band')
df_cursor_ex = pd.read_excel('lsfm_PSTH_cursors.xlsx', sheet_name='ex_band')
coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
idx_lsfm = df.index[(df['type']=='Log sFM') & (df['project']=='Ic_map') & (df['hard_exclude']!='exclude') 
                    &(df['tuning_check']!='exclude')]

neurons = []
data_cf, data_bw, data_mr=[],[],[]
#df_loc = 148
#if df_loc == 148:
#for idx, df_loc in enumerate(idx_lsfm):
for i in range(len(infos)):
    info = infos.iloc[i]
    # Load individual neuron data
    filename = info.filename
    mouseID = info.mouseID
    version = info.version
    site = info.patch_site
    tuning_tone = info.tuning_tone
    bf = info.best_frequency
    bandwidth = info.bandwidth
    band_left = info.band_left
    band_right = info.band_right
    
# =============================================================================
#     info_idx = info[info['index']==df_loc].index.values[0]
#     mouse = info['mouseID'][info_idx]
#     version = info['version'][info_idx]
#     site = info['patch_site'][info_idx]
#     tuning_tone = info['tuning_tone'][info_idx]
#     
#     bf = info['best_frequency'][info_idx]
#     bandwidth = info['bandwidth'][info_idx]
#     band_left = info['band_left'][info_idx]
#     band_right = info['band_right'][info_idx]
# =============================================================================
    
    cell_data = np.load(f'{filename}_lsfm.npy', allow_pickle=True)
    para = cell_data.item().get('para')
    stim = cell_data.item().get('stim')
    resp = cell_data.item().get('resp')
    resp = TFTool.prefilter(resp, 25000)
    
    titlename = f'{mouseID}-{filename}'
    if titlename=='TG145-20230630_008':
        titlename='TG145-20230628_003'
    if titlename=='TG145-20230630_004':
        titlename='TG145-20230630_008'
    
    
# =============================================================================
#     ### Get PSTH category value using visual cursors
#     def set_plus2zero(arr):
#         mask = arr>0
#         arr[mask] = 0
#         
#         return arr
#     
#     psth_main = Psth(stim, resp, para, titlename, version, bf, band_left, band_right, use_band=True)
#     psth_data = psth_main.get_psth()
#     for i in ['in', 'ex']:
#         if i == 'in':
#             psth= np.array(psth_data['y_in'])
#             cursor = df_cursor_in[(df_cursor_in['mouseID']==mouseID) & (df_cursor_in['filename']==filename)]
#         elif i == 'ex':
#             psth = np.array(psth_data['y_ex'])
#             cursor = df_cursor_ex[(df_cursor_ex['mouseID']==mouseID) & (df_cursor_ex['filename']==filename)]
#         
#         baseline = np.mean(psth[1000:1250])
#         plateau = np.mean(psth[26000:26250])
#         
#         on_peak_amp = cursor['onpeak_y'].item() - baseline
#         on_latency = (cursor['onpeak_start_x'].item() - 1250)/25000*1000    #unit: ms
#         start = int(cursor['onpeak_start_x'].item())
#         stop = int(cursor['onpeak_stop_x'].item())
#         on_charge = np.sum(psth[start:stop])
#         
#         off_peak_amp = cursor['offpeak_y'].item() - plateau
#         off_peak_amp_base = cursor['offpeak_y'].item() - baseline
#         off_latency = (cursor['offpeak_start_x'].item() - 26250)/25000*1000 #unit: ms
#         start = int(cursor['offpeak_start_x'].item())
#         stop = int(cursor['offpeak_stop_x'].item())
#         off_charge = np.sum(psth[start:stop])
#         
#         sustain = np.mean(psth[16250:26250])
#         
#         early = psth[int(cursor['onpeak_y'].item()):12500]
#         inhibit_early = np.sum(set_plus2zero(early))
#         
#         late = psth[12500:26250]
#         inhibit_late = np.sum(set_plus2zero(late))
#         
#         off = psth[26250:]
#         inhibit_off = np.sum(set_plus2zero(off))
#         
#         if i == 'in':
#             PSTH_in = [mouseID, filename, site, bf, bandwidth, on_peak_amp, on_latency, on_charge,
#                        off_peak_amp, off_peak_amp_base, off_latency, off_charge, 
#                        sustain, inhibit_early, inhibit_late, inhibit_off]
#         elif i == 'ex':
#             PSTH_ex = [mouseID, filename, site, bf, bandwidth, on_peak_amp, on_latency, on_charge,
#                        off_peak_amp, off_peak_amp_base, off_latency, off_charge, 
#                        sustain, inhibit_early, inhibit_late, inhibit_off]
#     
#     neurons.append([PSTH_in, PSTH_ex])
# =============================================================================
    
    
    ### Get PSTH category value using fixed window and machine code
    def set_plus2zero(arr):
        mask = arr>0
        arr[mask] = 0
        
        return arr
    
    psth_main = Psth(stim, resp, para, titlename, version, bf, band_left, band_right, use_band=True)
    psth_data = psth_main.get_psth()
    for condition in ['in', 'ex']:
        if condition == 'in':
            psth = np.array(psth_data['y_in'])
        elif condition == 'ex':
            psth = np.array(psth_data['y_ex'])
        
        baseline = np.mean(psth[1000:1250])
        plateau = np.mean(psth[26000:26250])
        std = np.std(psth[1250:26250])
        
        #on_peak, range 200 ms
        peak_max = np.max(psth[1250:6250])
        peak_min = np.min(psth[1250:6250])
        on_start = 1250
        
        if peak_min < 0 and abs(peak_min) > peak_max:
            on_peak_amp = peak_min - baseline
            peak_loc = np.argmin(psth[1250:6250])+1250
            
            for i in range(peak_loc+125, 26250):
                if (on_peak_amp*0.2 < plateau and psth[i] >= on_peak_amp*0.2) or (on_peak_amp*0.2 > plateau*0.8 and psth[i] >= plateau*0.8):
                    on_stop = i
                    break
        else:
            on_peak_amp = peak_max - baseline
            peak_loc = np.argmax(psth[1250:6250])+1250
            
            for i in range(peak_loc+125, 26250):
                if (on_peak_amp*0.2 > plateau and psth[i] <= on_peak_amp*0.2) or (on_peak_amp*0.2 < plateau*1.2 and psth[i] <= plateau*1.2):
                    on_stop = i
                    break
        
        on_latency = (peak_loc - 1250)/25000*1000    #unit: ms
        on_charge = np.sum(psth[on_start:on_stop])/1000
        
        #off_peak, range 250ms
        peak_max_pla = np.max(psth[26250:32500]) - plateau
        peak_max_bas = np.max(psth[26250:32500]) - baseline
        peak_min_pla = np.min(psth[26250:32500]) - plateau
        peak_min_bas = np.min(psth[26250:32500]) - baseline
        peak_max_loc = np.argmax(psth[26250:32500])+26250
        peak_min_loc = np.argmin(psth[26250:32500])+26250
        off_start = 26250
        
        # Exitotory Stimulus
        if plateau + std >= 0:
            if peak_min_pla > 0 and peak_min_loc > peak_max_loc:
                off_peak_amp_pla = peak_max_pla
                off_peak_amp_bas = peak_max_bas
                offpeak_loc = peak_max_loc
                for i in range(offpeak_loc+125, len(psth)):
                    if psth[i] <= baseline + std:
                        off_stop = i
                        determine = True
                        break
                
                if not determine:
                    for i in range(offpeak_loc+125, len(psth)):
                        if psth[i] <= plateau + peak_max_pla*0.2:
                            off_stop = i
                            determine = True
                            break
                
                if not determine:
                    off_stop = 32500
                
            elif peak_max_pla < std and peak_min_pla > peak_max_pla:
                off_peak_amp_pla = peak_min_pla
                off_peak_amp_bas = peak_min_bas
                offpeak_loc = peak_min_loc
                off_stop = peak_min_loc
                
            else:
                off_peak_amp_pla = peak_max_pla
                off_peak_amp_bas = peak_max_bas
                offpeak_loc = peak_max_loc
                for i in range(offpeak_loc+125, len(psth)):
                    if psth[i] <= baseline + std:
                        off_stop = i
                        determine = True
                        break
                
                if not determine:
                    for i in range(offpeak_loc+125, len(psth)):
                        if psth[i] <= plateau + peak_max_pla*0.2:
                            off_stop = i
                            determine = True
                            break
                
                if not determine:
                    off_stop = 32500
        
        # Inhibitory Stimulus
        elif plateau + std < 0:
            off_peak_amp_pla = peak_max_pla
            off_peak_amp_bas = peak_max_bas
            offpeak_loc = peak_max_loc
            for i in range(offpeak_loc+125, len(psth)):
                if psth[i] <= baseline + std:
                    off_stop = i
                    determine = True
                    break
            
            if not determine:
                for i in range(offpeak_loc+125, len(psth)):
                    if psth[i] <= plateau + peak_max_pla*0.2:
                        off_stop = i
                        determine = True
                        break
            
            if not determine:
                off_stop = 32500

        off_latency = (offpeak_loc - 26250)/25000*1000 #unit: ms
        
        off_charge = np.sum(psth[off_start:off_stop])/1000
        
        sustain = np.mean(psth[16250:26250])
        
        import copy
        early = copy.deepcopy(psth[peak_loc:12500])
        inhibit_early = np.sum(set_plus2zero(early))
        
        late = copy.deepcopy(psth[12500:26250])
        inhibit_late = np.sum(set_plus2zero(late))
        
        off = copy.deepcopy(psth[26250:])
        inhibit_off = np.sum(set_plus2zero(off))
        
        if condition == 'in':
            PSTH_in = [mouseID, filename, site, bf, bandwidth, on_peak_amp, on_latency, on_charge,
                       off_peak_amp_pla, off_peak_amp_bas, off_latency, off_charge, 
                       sustain, inhibit_early, inhibit_late, inhibit_off]
        elif condition == 'ex':
            PSTH_ex = [mouseID, filename, site, bf, bandwidth, on_peak_amp, on_latency, on_charge,
                       off_peak_amp_pla, off_peak_amp_bas, off_latency, off_charge, 
                       sustain, inhibit_early, inhibit_late, inhibit_off]
        
# =============================================================================
#         # Plot PSTH with category determinant
#         fig, ax = plt.subplots()
#         ax.plot(psth,color='k', label=f'{condition} RF')
#         ax.legend()
#         
#         ax.scatter(peak_loc, psth[peak_loc], s=70, c='r')
#         ax.scatter(on_stop, psth[on_stop], s=70, c='g')
#         ax.scatter(offpeak_loc, psth[offpeak_loc], s=70, c='r')
#         ax.scatter(off_stop, psth[off_stop], s=70, c='g')
#         
#         
#         [ax.axvline(x=_x, color='k', linestyle='--', alpha=0.5) for _x in [1250,26250]]
#         ax.set_xlim(0,len(psth))
#         label = list(np.round(np.linspace(0, 1.5, 16), 2))
#         ax.set_xticks(np.linspace(0,37500,16))
#         ax.set_xticklabels(label, rotation = 45)
#         #ax.xticks(rotation = 45)
#         #ax.set_title(f'{filename}_PSTH_BfBand', fontsize=14)
#         ax.set_title(f'{titlename} psth {condition} band', fontsize=18)
#         ax.set_xlabel('time (sec)', fontsize=16)
#         ax.set_ylabel('Membrane Potential (mV)', fontsize=16)
#         ax.tick_params(axis='both', which='major', labelsize=14)
#         
#         plt.savefig(f'{titlename}_PSTH_{condition}_band.png', dpi=500, bbox_inches='tight')
#         
#         plt.show()
#         plt.clf()
#         plt.close(fig)
# =============================================================================
        
        
        
    neurons.append([PSTH_in, PSTH_ex])
    
    
    ### Get PSTH category value separate by lsFM parameter
    stim_in, stim_ex, resp_in, resp_ex, para_in, para_ex, _, _ = lsfm.resp_bf_or_not(stim, resp, para, bf, [band_left, band_right])
    """psth seperated by parameter"""
    """0: cf, 1: bw, 2: mr"""
    psth_para_sep=[] #structure = (seperate para type, # of repeats, windows)
    para_sep=[] #structure = (seperate para type, tuple (parameter, # of repeats))
    for i in range(3):
        which_parameter=i
        psth_para_bf, para_bf = lsfm_psth.psth_para_sepearte(stim_in, resp_in, para_in, 
                                         which_parameter, bf, filename, 'inBF', plot=False, saveplot=False)
        psth_para_sep.append(psth_para_bf)
        para_sep.append(para_bf)
    
        
    resp_flat = np.reshape(resp, (-1))
    resp_flat = TFTool.butter(resp_flat, 6, 50, 'low', 25000)
    import random
    randoms = random.sample(range(50,len(resp_flat)),1000)
    
    category_cf = lsfm_psth.get_section(filename, mouseID, site, psth_para_sep, para_sep, 0)
    category_bw = lsfm_psth.get_section(filename, mouseID, site, psth_para_sep, para_sep, 1)
    category_mr = lsfm_psth.get_section(filename, mouseID, site, psth_para_sep, para_sep, 2)
    
    from_bf = np.log2(np.array(category_cf['parameter']) / (bf/1000))
    category_cf['parameter'] = list(from_bf)
    
    
    data_cf.append(category_cf)
    data_bw.append(category_bw)
    data_mr.append(category_mr)
    
    
### Neuron PSTH output    
neurons_arr = np.array(neurons)
# Split data into "in" and "out"
in_data = neurons_arr[:, 0, :]   # shape (39, 11)
ex_data = neurons_arr[:, 1, :]  # shape (39, 11)

# Create DataFrames
category_labels = ['mouseID', 'filename', 'patch_site', 'bf', 'bandwidth',
                   'onpeak', 'on_latency', 'on_charge', 'offpeak', 'offpeak_base', 
                   'off_latency', 'off_charge', 'sustain', 'inhibit_early', 'inhibit_late', 
                   'inhibit_off']

df_in = pd.DataFrame(in_data, columns=category_labels)
df_out = pd.DataFrame(ex_data, columns=category_labels)

# Write to Excel with two sheets
with pd.ExcelWriter("lsfm_PSTH_category_new.xlsx", engine="openpyxl") as writer:
    df_in.to_excel(writer, sheet_name="inband")
    df_out.to_excel(writer, sheet_name="exband")    
    
    

### Plot para_sep categories, color coded with x-projection
df_cf = pd.DataFrame(data_cf)
df_bw = pd.DataFrame(data_bw)
df_mr = pd.DataFrame(data_mr)

categories = list(df_cf.keys())
for para_type in range(3):
    df_type = [df_cf, df_bw, df_mr][para_type]
    for cate in categories[:-5]:
        lsfm_psth.plot_group_category(df_type, coords, para_type, cate, normalize=False)
        

### Linear fit para_sep for each neuron in each dataframe
def prepare_output_df(df, slope_df, r2_df, pval_df):
    # Keep identifying info
    info_cols = ['mouseID', 'filename', 'patch_site']
    info = df[info_cols].copy()

    # Measurement labels
    categories = slope_df.columns

    # Create multi-column result
    results = pd.DataFrame(index=df.index)
    for cat in categories:
        results[f'{cat}_slope'] = slope_df[cat]
        results[f'{cat}_r2'] = r2_df[cat]
        results[f'{cat}_pval'] = pval_df[cat]

    # Combine and return
    return pd.concat([info, results], axis=1)

# Run fits
slope_cf, r2_cf, pval_cf = lsfm_psth.fit_para_sep(df_cf, use_log_x=False)
slope_mr, r2_mr, pval_mr = lsfm_psth.fit_para_sep(df_mr, use_log_x=True)
slope_bw, r2_bw, pval_bw = lsfm_psth.fit_para_sep(df_bw, use_log_x=True)

# Prepare dataframes
df_cf_out = prepare_output_df(df_cf, slope_cf, r2_cf, pval_cf)
df_mr_out = prepare_output_df(df_mr, slope_mr, r2_mr, pval_mr)
df_bw_out = prepare_output_df(df_bw, slope_bw, r2_bw, pval_bw)

# Save to Excel
with pd.ExcelWriter("para_sep_fit.xlsx") as writer:
    df_cf_out.to_excel(writer, sheet_name='df_cf', index=False)
    df_mr_out.to_excel(writer, sheet_name='df_mr', index=False)
    df_bw_out.to_excel(writer, sheet_name='df_bw', index=False)
    
# Save to compressed .npz file
np.savez_compressed(
    'para_sep_fit.npz',
    df_cf_out=df_cf_out.to_dict(),
    df_mr_out=df_mr_out.to_dict(),
    df_bw_out=df_bw_out.to_dict()
)


### Split para_sep result into 2 or 3 groups, low, (mid), high and plot
cf_low, cf_high = lsfm_psth.para_sep_split2(df_cf, cutoff=0)
bw_low, bw_high = lsfm_psth.para_sep_split2(df_bw, cutoff=1)
mr_low, mr_high = lsfm_psth.para_sep_split2(df_mr, cutoff=20)
    
lsfm_psth.plot_para_sep_split2(cf_low, cf_high, title='CF: Low vs High (Normalized)', saveplot=True)
lsfm_psth.plot_para_sep_split2(bw_low, bw_high, title='BW: Low vs High (Normalized)', saveplot=True)
lsfm_psth.plot_para_sep_split2(mr_low, mr_high, title='MR: Low vs High (Normalized)', saveplot=True)
        
bw_low, bw_mid, bw_high = lsfm_psth.para_sep_split3(df_bw, norm_factor=1, cutoff1=0.05, cutoff2=1)
lsfm_psth.plot_para_sep_split3(bw_low, bw_mid, bw_high, title='BW: Low vs Mid vs High', saveplot=True, filename='bw_3groups.png')

mr_low, mr_mid, mr_high = lsfm_psth.para_sep_split3(df_mr, norm_factor=1, cutoff1=10, cutoff2=30)
lsfm_psth.plot_para_sep_split3(mr_low, mr_mid, mr_high, title='MR: Low vs Mid vs High', saveplot=True, filename='mr_3groups.png')