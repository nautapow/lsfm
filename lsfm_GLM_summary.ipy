import numpy as np
import os
import matplotlib.pyplot as plt
from scipy import signal
from scipy import stats as scipy_stats
from scipy import interpolate
import scipy.io
import TFTool
import pandas as pd
import lsfm
import lsfm_psth
from lsfm_psth import Psth
import math
import lsfm_strf
%matplotlib inline

# Groups and fixed feature order (used for BOTH plots)
groups = ['linear', 'quadratic', 'interaction']
FEATURES_ORDER = [
    'onP_amp', 'on_latency', 'on_charge',
    'offP_amp_pla', 'offP_amp_bas', 'off_latency', 'off_charge',
    'sustain', 'inhibit_early', 'inhibit_late', 'inhibit_off'
]

# Excel writer for summary
excel_path = "glm_r2_summary.xlsx"
writer = pd.ExcelWriter(excel_path, engine="openpyxl")

# Store CV R² for all groups for combined plot
cv_r2_all = pd.DataFrame(index=FEATURES_ORDER, columns=groups)

t_test_results = []

for group in groups:
    df = pd.read_csv(f'neuron_glm_{group}_summary.csv')

    # Keep only known features, set a consistent ordered category, and sort by that
    df = df[df['feature'].isin(FEATURES_ORDER)].copy()
    df['feature'] = pd.Categorical(df['feature'], categories=FEATURES_ORDER, ordered=True)
    df.sort_values('feature', inplace=True)

    # Features actually present in this group (preserves the fixed order)
    features = [f for f in FEATURES_ORDER if (df['feature'] == f).any()]

    # Compute mean per feature (and write to Excel) in the same order
    mean_stats = (
        df.groupby("feature")[["train_r2", "loo_r2", "overfitting"]]
          .mean()
          .reindex(features)
    )
    mean_stats.to_excel(writer, sheet_name=group)

    # ── Scatter plot ──────────────────────────────────────────────────────────────
    plt.figure(figsize=(12, 6))
    x = np.arange(len(features))

    for i, feature in enumerate(features):
        subdf = df[df["feature"] == feature]
        # Scatter dots
        plt.scatter(np.full(len(subdf), x[i] - 0.1), subdf["train_r2"], color="blue",
                    marker="o", alpha=0.6, label="Train R²" if i == 0 else "")
        plt.scatter(np.full(len(subdf), x[i] + 0.1), subdf["loo_r2"], color="green",
                    marker="o", alpha=0.6, label="CV R²" if i == 0 else "")
        # Connect each neuron’s train vs CV
        for _, row in subdf.iterrows():
            plt.plot([x[i] - 0.1, x[i] + 0.1],
                     [row["train_r2"], row["loo_r2"]],
                     color="gray", alpha=0.5)
        # Mean lines (per feature)
        plt.hlines(mean_stats.loc[feature, "train_r2"], x[i] - 0.2, x[i], color="red", linewidth=2)
        plt.hlines(mean_stats.loc[feature, "loo_r2"],   x[i], x[i] + 0.2, color="red", linewidth=2)

    # Baseline at 0
    plt.axhline(0, color="black", linestyle="--", linewidth=1)

    plt.xticks(x, features, rotation=45, ha="right")
    plt.ylim(-0.8, 0.7)  # keep your current limits; set to (-2, 1) if you prefer
    plt.ylabel("R²")
    plt.title(f"Train vs CV R² per Feature ({group.capitalize()} Model)")
    plt.legend()
    plt.tight_layout()

    # Save & show
    plot_path = f"glm_r2_{group}.png"
    plt.savefig(plot_path, dpi=300)
    plt.show()
    plt.close()

    # ── Bar graph with error bars (same feature order as scatter) ────────────────
    stats_df = (
        df.groupby("feature")[["train_r2", "loo_r2"]]
          .agg(["mean", "std"])
          .reindex(features)
    )
    train_mean, train_std = stats_df[("train_r2", "mean")], stats_df[("train_r2", "std")]
    test_mean,  test_std  = stats_df[("loo_r2",   "mean")], stats_df[("loo_r2",   "std")]

    plt.figure(figsize=(12, 6))
    x = np.arange(len(features))
    width = 0.35

    plt.bar(x - width/2, train_mean.values, width, yerr=train_std.values, capsize=5, alpha=0.7, label="Train R²")
    plt.bar(x + width/2, test_mean.values,  width, yerr=test_std.values,  capsize=5, alpha=0.7, label="CV R²")

    plt.axhline(0, color="black", linestyle="--", linewidth=1)

    plt.xticks(x, features, rotation=45, ha="right")
    plt.ylabel("Mean R² ± SD")
    plt.ylim(-0.4, 0.5)  # keep your current limits; set to (-2, 1) if you prefer
    plt.title(f"Mean Train vs CV R² per Feature ({group.capitalize()} Model)")
    plt.legend()
    plt.tight_layout()

    bar_path = f"glm_r2_mean_{group}.png"
    plt.savefig(bar_path, dpi=300)
    plt.show()
    plt.close()
    
    # Store mean CV R² for combined bar graph
    cv_r2_all[group] = test_mean.reindex(FEATURES_ORDER)
    
    # ── T-test on CV R² (only if mean > 0) ─────────
    for feature in features:
        feature_data = df[df['feature'] == feature]['loo_r2'].dropna()
        mean_val = feature_data.mean()
        if len(feature_data) > 1 and mean_val > 0:
            t_stat, p_val = scipy_stats.ttest_1samp(feature_data, popmean=0, alternative='greater')
            t_test_results.append({
                'model': group,
                'feature': feature,
                'n': len(feature_data),
                'mean_loo_r2': mean_val,
                't_stat': t_stat,
                'p_value': p_val
            })
    

# ── Combined CV R² bar graph ───────────────
x = np.arange(len(FEATURES_ORDER))
width = 0.25

plt.figure(figsize=(14, 6))
for i, group in enumerate(groups):
    mean_vals = cv_r2_all[group].values
    # Compute SDs for error bars
    df_group = pd.read_csv(f'neuron_glm_{group}_summary.csv')
    df_group = df_group[df_group['feature'].isin(FEATURES_ORDER)]
    stats = df_group.groupby('feature')['loo_r2'].agg(['mean', 'std']).reindex(FEATURES_ORDER)
    std_vals = stats['std'].values
    plt.bar(x + (i-1)*width, mean_vals, width, yerr=std_vals, capsize=5, alpha=0.7, label=group.capitalize())

plt.axhline(0, color='black', linestyle='--', linewidth=1)
plt.xticks(x, FEATURES_ORDER, rotation=45, ha='right')
plt.ylabel("Mean CV R² ± SD")
plt.title("CV R² per Feature Across All Models")
plt.legend()
plt.tight_layout()
plt.savefig("cv_r2_all_models.png", dpi=300)
plt.show()
plt.close()

# ── Save T-test results ──────────────────────────
t_test_df = pd.DataFrame(t_test_results)
t_test_df = t_test_df.sort_values(by=['model', 'feature']).reset_index(drop=True)
t_test_df.to_excel(writer, sheet_name='t_test_results', index=False)

# Save Excel
writer.close()
print(f"Excel summary saved to: {excel_path}")
print("T-test summary:\n", t_test_df.head(20))


# ── Combined CV R² bar graph with SEM and p-value labels ──────────────
x = np.arange(len(FEATURES_ORDER))
width = 0.25

plt.figure(figsize=(16, 7))

for i, group in enumerate(groups):
    # Filter group data
    df_group = pd.read_csv(f'neuron_glm_{group}_summary.csv')
    df_group = df_group[df_group['feature'].isin(FEATURES_ORDER)]

    # Compute mean and SEM for each feature
    stats = (
        df_group.groupby('feature')['loo_r2']
        .agg(['mean', 'std', 'count'])
        .reindex(FEATURES_ORDER)
    )
    sem_vals = (stats['std'] / np.sqrt(stats['count'])).values
    mean_vals = stats['mean'].values

    # Plot bars with SEM
    plt.bar(x + (i-1)*width, mean_vals, width, yerr=sem_vals, capsize=5, alpha=0.8, label=group.capitalize())

    # Add p-value labels
    for j, feature in enumerate(FEATURES_ORDER):
        p_label = ""
        match = t_test_df[(t_test_df['model'] == group) & (t_test_df['feature'] == feature)]
        if not match.empty:
            p_val = match.iloc[0]['p_value']
            # Decide significance stars
            if p_val < 0.001:
                p_label = "***"
            elif p_val < 0.01:
                p_label = "**"
            elif p_val < 0.05:
                p_label = "*"
            else:
                p_label = "ns"
            
            # Annotate just above bar
            plt.text(
                x[j] + (i-1)*width, 
                mean_vals[j] + sem_vals[j] + 0.02,  # position above error bar
                p_label,
                ha='center', va='bottom', fontsize=10, fontweight='bold'
            )

# Styling
plt.axhline(0, color='black', linestyle='--', linewidth=1)
plt.xticks(x, FEATURES_ORDER, rotation=45, ha='right')
plt.ylim(-0.05, 0.2)
plt.ylabel("Mean CV R² ± SEM")
plt.title("CV R² Across Models")
plt.legend(title="Model")
plt.tight_layout()

# Save plot
plt.savefig("cv_r2_all_models_sem_pval.png", dpi=300)
plt.show()
plt.close()


# ── Standalone Histogram of CV R² for Each Feature and Each Group ──────────────
hist_output_dir = "cv_r2_histograms_new"
os.makedirs(hist_output_dir, exist_ok=True)

# Define consistent bin range across all plots
bin_edges = np.linspace(-0.5, 0.5, 30)  # adjust as needed

for group in groups:
    # Load and filter data for this model group
    df_group = pd.read_csv(f'neuron_glm_{group}_summary.csv')
    df_group = df_group[df_group['feature'].isin(FEATURES_ORDER)]

    for feature in FEATURES_ORDER:
        # Extract CV R² data for this feature
        feature_data = df_group[df_group['feature'] == feature]['loo_r2'].dropna()

        # Skip if there's no data for this feature
        if len(feature_data) == 0:
            continue

        # Create a standalone histogram plot
        plt.figure(figsize=(6, 4))
        plt.hist(feature_data, bins=bin_edges, color='skyblue', edgecolor='black', alpha=0.8)

        # Reference line at 0
        plt.axvline(0, color='red', linestyle='--', linewidth=1)

        # Titles and labels
        plt.title(f"CV R² Distribution\n{group.capitalize()} Model - {feature}", fontsize=14)
        plt.xlabel("CV R²")
        plt.ylabel("Count")

        # Clean layout
        plt.tight_layout()

        # Save each plot as a separate file
        filename = f"{group}_{feature}_cv_r2_histogram.png"
        save_path = os.path.join(hist_output_dir, filename)
        plt.savefig(save_path, dpi=300)
        plt.close()

        print(f"Saved histogram: {save_path}")
