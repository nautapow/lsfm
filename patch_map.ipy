import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
from scipy import signal,stats
import TFTool
import tone
import pandas as pd
import itertools
from lsfm_psth import Psth
import math
import regression


%matplotlib inline
df = pd.read_csv('patch_list_E.csv', dtype={'date':str, '#':str})
idx_tone = df.index[(df['type']=='Pure Tones') & (df['project']!='Vc') & (df['hard_exclude']!='exclude')]
idx_tone = [i for i in idx_tone if i > 146]
idx_lsfm = df.index[(df['type']=='Log sFM') & (df['project']!='Vc') & (df['hard_exclude']!='exclude')]
idx_lsfm = [i for i in idx_lsfm if i > 146]
jitter = pd.read_csv('jitter.csv')

# =============================================================================
# #region = [x0:x3], [y0:y3], [x_err1:x_err3], [y_err1:yerr3]
# region = [[0, 1.0, 0.0, 1.029], [0, 0.0, 0.926, 0.726], [0.02, 0.02, 0.02, 0.203], [0.04, 0.04, 0.223, 0.166]]
# region_4p = [[0, 0.548, 0.548, 1.0], [0, -0.379, 0.471, 0.0], [0.02, 0.059, 0.059, 0.02], [0.02, 0.123, 0.094, 0.02]]
# =============================================================================
#A1AAF 
#region = [-0.54788889, 0, 0, 0.45211111], [0, 0.44133333, -0.55866667, 0], [0.01420644, 0, 0, 0.01420644], [0, 0.02509863, 0.02509863, 0]
#A1A2 - mid
region = [-0.5, -0.213, 0.5, 0.606], [0, 1.086, 0, 1.086], [0, 0.042, 0, 0.053], [0, 0.059, 0, 0.053]

"""analysis type"""
saveplot=False


get_region = False
map_patch = False
tone_analysis = False
lsfm_analysis = False
intrisic_analysis = False
para_sep_fit = True
spike_analysis = False



def detect_outliers(arr):
    from scipy.special import erfcinv
    arr = np.array(arr)
    
    # --- IQR Method ---
    q1 = np.percentile(arr, 25)
    q3 = np.percentile(arr, 75)
    iqr = q3 - q1
    lower_iqr = q1 - 1.5 * iqr
    upper_iqr = q3 + 1.5 * iqr
    iqr_mask = (arr < lower_iqr) | (arr > upper_iqr)

    # --- MAD Method ---
    median = np.median(arr)
    mad = np.median(np.abs(arr - median))
    c = -1 / (np.sqrt(2) * erfcinv(3/2))  # scale constant
    scaled_mad = c * mad
    mad_mask = np.abs(arr - median) > 3 * scaled_mad

    # --- Combined: Only mark as outlier if both methods agree ---
    combined_mask = iqr_mask & mad_mask
    
    return combined_mask


from collections import defaultdict

def compute_radial_spread_coords(x_list, y_list, ids, radius=0.05):
    """
    Generate radiating coordinates for overlapping IDs.
    Returns scattered x/y coords and a list of lines from center to each point.
    """
    from collections import defaultdict
    import numpy as np

    coord_dict = defaultdict(list)
    for i, key in enumerate(ids):
        coord_dict[key].append(i)

    xs, ys = np.array(x_list), np.array(y_list)
    out_x, out_y = np.copy(xs), np.copy(ys)
    lines = []

    for key, indices in coord_dict.items():
        n = len(indices)
        if n > 1:
            center_x = xs[indices[0]]
            center_y = ys[indices[0]]
            angles = np.linspace(0, 2*np.pi, n, endpoint=False)
            for angle, idx in zip(angles, indices):
                dx = radius * np.cos(angle)
                dy = radius * np.sin(angle)
                out_x[idx] += dx
                out_y[idx] += dy
                lines.append((center_x, center_y, out_x[idx], out_y[idx]))
    
    return out_x, out_y, lines

def plot_map(patch_x, patch_y, arr, ids, region=region, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    from matplotlib import patches, colors

    arr = np.array(arr)
    patch_x, patch_y = np.array(patch_x), np.array(patch_y)

    # New: Get radiated coordinates and center-line segments
    scatter_x, scatter_y, center_lines = compute_radial_spread_coords(patch_x, patch_y, ids, radius=0.05)

    region_xy = list(zip(region[0], region[1]))

    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    cmap = kwargs.get('cmap', 'inferno')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')
    diverge = kwargs.get('diverge', False)

    norm = colors.CenteredNorm() if diverge else None
    if diverge:
        cmap = 'RdYlBu_r'

    fig, ax = plt.subplots()

    # Draw region ovals
    for i in range(len(region_xy)):
        ellipse = patches.Ellipse(region_xy[i], 0.05, 0.05, angle=0, color='grey', alpha=0.9)
        ax.add_patch(ellipse)

    # New: Draw dashed lines from patch center to each radiated point
    for x0, y0, x1, y1 in center_lines:
        ax.plot([x0, x1], [y0, y1], linestyle='dashed', color='gray', alpha=0.6, linewidth=1)

    # Scatter plot
    if outlier_mask is not None:
        inliers = ~outlier_mask
        outliers = outlier_mask
        sc = ax.scatter(scatter_x[inliers], scatter_y[inliers], c=arr[inliers], cmap=cmap,
                        s=120, alpha=0.9, vmin=vmin, vmax=vmax, norm=norm)
        ax.scatter(scatter_x[outliers], scatter_y[outliers], c='gray', s=120, alpha=0.5, label='Outlier')
    else:
        sc = ax.scatter(scatter_x, scatter_y, c=arr, cmap=cmap,
                        s=120, alpha=0.9, vmin=vmin, vmax=vmax, norm=norm)

    # Colorbar
    cbar = fig.colorbar(sc, ax=ax)
    cbar.ax.set_ylabel(ylabel, fontsize=16)

    ax.set_xlabel('A1 low – A2 high', fontsize=16)
    ax.set_ylabel('A1–A2 orthogonal', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)
    ax.legend()

    if saveplot:
        plt.savefig(f'{title}_map.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()


def plot_ortho_xx(ortho_x, arr, fit, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    import numpy as np

    ortho_x, arr = np.array(ortho_x), np.array(arr)
    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')

    fig, ax = plt.subplots()

    if outlier_mask is not None:
        inliers = ~outlier_mask
        ax.scatter(ortho_x[inliers], arr[inliers], s=50, alpha=0.7, color='blue')
        ax.scatter(ortho_x[outlier_mask], arr[outlier_mask], s=50, alpha=0.5, color='gray', label='Outlier')
    else:
        ax.scatter(ortho_x, arr, s=50, alpha=0.7)
    
    if 'best frequency' in ylabel.lower():
        ax.set_yscale('log')
    
    ax.plot(fit[0], fit[1], color='red', label='Fit')
    ax.annotate(f'$R^2$: {fit[2]:.2f}', xy=(0.99, 0.97), xycoords='axes fraction', size=14, ha='right', va='top')
    ax.annotate(f'P = {float(fit[3]):.3g}', xy=(0.99, 0.90), xycoords='axes fraction', size=14, ha='right', va='top')

    ax.set_ylabel(ylabel, fontsize=16)
    ax.set_xlabel('X-axis projection', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)

    if vmin is not None and vmax is not None:
        ax.set_ylim(vmin, vmax)

    ax.legend(loc='upper left')

    if saveplot:
        plt.savefig(f'{title}_orthoX.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()
    
def plot_ortho_yy(ortho_y, arr, fit, saveplot=False, outlier_mask=None, **kwargs):
    import matplotlib.pyplot as plt
    import numpy as np

    ortho_y, arr = np.array(ortho_y), np.array(arr)
    title = kwargs.get('title', '')
    ylabel = kwargs.get('ylabel', '')
    vmax = kwargs.get('vmax')
    vmin = kwargs.get('vmin')

    fig, ax = plt.subplots()

    if outlier_mask is not None:
        inliers = ~outlier_mask
        ax.scatter(ortho_y[inliers], arr[inliers], s=50, alpha=0.7, color='blue')
        ax.scatter(ortho_y[outlier_mask], arr[outlier_mask], s=50, alpha=0.5, color='gray', label='Outlier')
    else:
        ax.scatter(ortho_y, arr, s=50, alpha=0.7)
        
    if 'best frequency' in ylabel.lower():
        ax.set_yscale('log')
        
    ax.plot(fit[0], fit[1], color='red', label='Fit')
    ax.annotate(f'$R^2$: {fit[2]:.2f}', xy=(0.99, 0.97), xycoords='axes fraction', size=14, ha='right', va='top')
    ax.annotate(f'P = {fit[3]:.3g}', xy=(0.99, 0.90), xycoords='axes fraction', size=14, ha='right', va='top')

    ax.set_ylabel(ylabel, fontsize=16)
    ax.set_xlabel('Y-axis projection', fontsize=16)
    ax.tick_params(axis='both', which='major', labelsize=14)

    if vmin is not None and vmax is not None:
        ax.set_ylim(vmin, vmax)

    ax.legend(loc='upper left')

    if saveplot:
        plt.savefig(f'{title}_orthoY.png', dpi=500, bbox_inches='tight')
    plt.show()
    plt.close()
    
def check_map(df, x, y, ortho, arr):
    import plotly.io as pio
    import plotly.express as px
    pio.renderers.default='browser'
    
    mouseid = list(df['mouseid'])
    site = list(df['patch_site'])
    filename = list(df['filename']) 
    name = [f'{a[0]}_{a[1]}_{filename[i]}' for i ,a in enumerate(list(zip(mouseid, site)))]
    
    x_dev = np.random.normal(0, .05, len(x))
    fig = px.scatter(x = ortho+x_dev, y = arr, text=name)
    fig.show()
    
    fig = px.scatter(x=x+x_dev, y=y+x_dev, text=name)
    fig.show()

    
    
if map_patch:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    tone_info = pd.read_excel('tone_cell_note.xlsx')
    mouseid = list(tone_info['mouseID'])
    filename = list(tone_info['filename'])
    sites = list(tone_info['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseid):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
        
    
    
    ids = [f'{a}_{b}_{c}' for (a,b,c) in zip(filename, mouseid, sites)]
    title='Patch Map'
    patch_x = np.array(patch_x)
    patch_y = np.array(patch_y)
    

    x_range = patch_x.max() - patch_x.min()
    y_range = patch_y.max() - patch_y.min()
    
    x_jitter = (np.random.rand(len(patch_x)) - 0.5) * 0.05 * x_range
    y_jitter = (np.random.rand(len(patch_y)) - 0.5) * 0.3 * y_range
    
    # Apply jitter
    jittered_x = patch_x + x_jitter
    jittered_y = patch_y + y_jitter
    
    # Plot
    plt.figure(figsize=(8, 6))
    plt.scatter(jittered_x, jittered_y, color='blue', s=20)
    
    # Add jittered labels
    for i, txt in enumerate(ids):
        plt.text(jittered_x[i], jittered_y[i], txt, fontsize=8, ha='right', va='bottom')
    
    plt.title('Patch Map')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.axis('equal')
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('map_neuonIDs.png', dpi=500, bbox_inches='tight')
    plt.show()

# =============================================================================
#     #mapping each levels
#     bf_levels = pd.read_excel('tone_para_levels.xlsx', 'bf')
#     band_levels = pd.read_excel('tone_para_levels.xlsx', 'bandwidth')
#     
#     for level in ['40db', '50db', '60db', '70db', '80db']:
#         bfs, bands = [],[]
#         for (ids, names) in zip(mouseid, filename):
#             bfs.append(bf_levels[(bf_levels['mouseID']==ids) & (bf_levels['filename']==names)][level])
#             bands.append(band_levels[(bf_levels['mouseID']==ids) & (bf_levels['filename']==names)][level])
#         
#         bf = np.array(bfs)/1000
#         plot_map(patch_x, patch_y, bf, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)', cmap='viridis')
#         #regression.regression_test(ortho, bf)
#         fit_orthox = regression.regression_poly(ortho_x, bf, degree=1)
#         fit_orthoy = regression.regression_poly(ortho_y, bf, degree=1)
#         plot_ortho_xx(ortho_x, bf, fit_orthox, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)')
#         plot_ortho_yy(ortho_y, bf, fit_orthoy, saveplot=True, title=f'Best_Frequency {level}', ylabel=f'Best_Frequency {level} (kHz)')
# 
#         bandwidth = np.array(bands)
#         plot_map(patch_x, patch_y, bandwidth, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)', cmap='viridis')
#         #regression.regression_test(ortho, bf)
#         fit_orthox = regression.regression_poly(ortho_x, bandwidth, degree=1)
#         fit_orthoy = regression.regression_poly(ortho_y, bandwidth, degree=1)
#         plot_ortho_xx(ortho_x, bandwidth, fit_orthox, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)')
#         plot_ortho_yy(ortho_y, bandwidth, fit_orthoy, saveplot=True, title=f'Bandwidth {level}', ylabel=f'Bandwidth {level} (octave)')
# =============================================================================


if tone_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    tone_psth = pd.read_excel('tone_PSTH_category.xlsx', sheet_name='inband')
    mouseid = list(tone_psth['mouseID'])
    filename = list(tone_psth['filename'])
    sites = list(tone_psth['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseid):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    ids = list(zip(mouseid, sites))
    
    parameters = {
        'bf': ('Best_Frequency', 'Best Frequency (kHz)', 'turbo'),
        'bandwidth': ('Bandwidth', 'Bandwidth (octave)', 'turbo'),
        'peak': ('Peak_Amplitude', 'Peak Amplitude (mV)', 'turbo'),
        'latency': ('Time_to_Peak', 'Time to Peak (ms)', 'turbo'),
        'peri_charge': ('peri_charge', 'Peri-Integration (mV*ms)', 'turbo'),
        'post_charge': ('post_charge', 'Post-Integration (mV*ms)', 'turbo'),
    }

    for key, (title, ylabel, cmap) in parameters.items():
        values = np.array(tone_psth[key])
        if key == 'bf':
            values = values / 1000  # Convert to kHz
            log_values = np.log10(values)
            outlier_mask = detect_outliers(log_values)
            
            # Fit using log(BF)
            fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], log_values[~outlier_mask], degree=1)
            fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], log_values[~outlier_mask], degree=1)
            
            # Convert fit back to raw kHz space for plotting
            fit_x_vals = fit_x[0]
            fit_x_curve = 10**np.array(fit_x[1])
            fit_x = (fit_x_vals, fit_x_curve, fit_x[2], fit_x[3])
            
            fit_y_vals = fit_y[0]
            fit_y_curve = 10**np.array(fit_y[1])
            fit_y = (fit_y_vals, fit_y_curve, fit_y[2], fit_y[3])
            
            plot_map(patch_x, patch_y, values, ids=ids, saveplot=True, title=title,
                     ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)
    
            plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)
    
            plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)
            
        else:  
            outlier_mask = detect_outliers(values)
    
            fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
            fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)
    
            plot_map(patch_x, patch_y, values, ids=ids, saveplot=True, title=title,
                     ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)
    
            plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)
    
            plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)
    

if lsfm_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    lsfm_psth_inBF = pd.read_excel('lsfm_PSTH_category_bf.xlsx', sheet_name='inband')
    lsfm_psth_exBF = pd.read_excel('lsfm_PSTH_category_bf.xlsx', sheet_name='exband')
    
    mouseIDs = list(lsfm_psth_inBF['mouseID'])
    sites = list(lsfm_psth_inBF['patch_site'])
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,m in enumerate(mouseIDs):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    
    parameters = {
    'onpeak': ('OnPeak_Amplitude', 'Onset Peak Amplitude (mV)', None, None),
    'on_latency': ('Time_to_Peak', 'Time to Onset Peak (ms)', None, None),
    'on_charge': ('Onset_Charge', 'Onset Integrated Polarization (mV*s)', None, None),
    'sustain': ('Sustain', 'Sustain Potential (mV)', None, None),
    'offpeak': ('OffPeak_Amplitude', 'Offset Peak Amp plateau (mV)', None, None),
    'offpeak_base': ('OffPeak_Amplitude_baseline', 'Offset Peak Amp baseline (mV)', None, None),
    'off_charge': ('Offset_Charge', 'Offset Integrated Polarization (mV*s)', None, None),
    }

    for condition in ['inband', 'exband']:
        working = lsfm_psth_inBF if condition == 'inband' else lsfm_psth_exBF
        
        for param_key, (title_base, ylabel, vmin, vmax) in parameters.items():
            values = np.array(working[param_key])
            ids = list(zip(mouseIDs, sites))  # use tuple as unique key
            
            # 1. Detect outliers
            outlier_mask = detect_outliers(values)
            
            # 2. Filter for regression (only inliers)
            fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
            fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)
            
            # 3. Plot with highlighting
            plot_map(patch_x, patch_y, values, ids=ids, saveplot=True,
                     title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)
            
            plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                          title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)
            
            plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                          title=f'{title_base}_{condition}', ylabel=ylabel, vmin=vmin, vmax=vmax, outlier_mask=outlier_mask)


        
if intrisic_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    intrisic = pd.read_excel('intrinsic_properties.xlsx')
    mouseid = list(intrisic['mouseID'])
    filename = list(intrisic['filename'])
    sites = list(intrisic['patch_site'])
    
    patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
    for i,(m,s) in enumerate(zip(mouseid, sites)):
        site = f'Patch_{s}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12.item())
        ortho_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A12m.item())
    
    parameters = {
        'resting': ('resting_potential', 'Resting Potential (mV)', 'magma'),
        'spike_rate': ('spike_rate', 'Spike Rate (Hz)', 'magma'),
        'spike_width': ('spike_width', 'Spike Width (ms)', 'magma'),
        'R_all': ('resistance', 'Input Resistance (MΩ)', 'magma'),
        'adaptation': ('adaptation', 'Spike Adaptation (ISI index)', 'magma'),
    }

    for key, (title, ylabel, cmap) in parameters.items():
        values = np.array(intrisic[key])
        ids = list(zip(mouseid, sites))
        
        outlier_mask = detect_outliers(values)

        fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
        fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)

        plot_map(patch_x, patch_y, values, ids=ids, saveplot=True, title=title,
                 ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)

        plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)

        plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                      title=title, ylabel=ylabel, outlier_mask=outlier_mask)


if para_sep_fit:
    def plot_slope_maps(result_df, coords, name_prefix=''):
        measurement_labels = [
            'onP_amp', 'on_latency', 'on_charge',
            'offP_amp_pla', 'offP_amp_bas', 'off_latency',
            'off_charge', 'sustain',
            'inhibit_early', 'inhibit_late', 'inhibit_off'
        ]
        
        # Collect coordinates
        mouseid = list(result_df['mouseID'])
        filename = list(result_df['filename'])
        sites = list(result_df['patch_site'])
    
        patch_x, patch_y, ortho_x, ortho_y = [],[],[],[]
        for m, s in zip(mouseid, sites):
            site = f'Patch_{s}'
            row = coords[(coords['mouseid'] == m) & (coords['regions'] == site)]
            if row.empty:
                patch_x.append(np.nan)
                patch_y.append(np.nan)
            else:
                patch_x.append(row['x_A12'].item())
                patch_y.append(row['y_A12'].item())
                ortho_x.append(row['ortho_A12'].item())
                ortho_y.append(row['ortho_A12m'].item())
    
        patch_x = np.array(patch_x)
        patch_y = np.array(patch_y)
        ortho_x = np.array(ortho_x)
        ortho_y = np.array(ortho_y)
    
        # Plot each slope map
        for cat in measurement_labels:
            values = np.array(result_df[f'{cat}_slope'], dtype=np.float64)
            ids = list(zip(mouseid, sites))
    
            outlier_mask = detect_outliers(values)
            outlier_mask[:] = False
            
            fit_x = regression.regression_poly(np.array(ortho_x)[~outlier_mask], values[~outlier_mask], degree=1)
            fit_y = regression.regression_poly(np.array(ortho_y)[~outlier_mask], values[~outlier_mask], degree=1)
    
            title = f'{name_prefix} - {cat} slope'
            ylabel = f'{cat} Slope'
            cmap = 'viridis'
    
            plot_map(patch_x, patch_y, values, ids=ids, saveplot=True,
                     title=title, ylabel=ylabel, cmap=cmap, outlier_mask=outlier_mask)
            
            plot_ortho_xx(ortho_x, values, fit_x, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)

            plot_ortho_yy(ortho_y, values, fit_y, saveplot=True,
                          title=title, ylabel=ylabel, outlier_mask=outlier_mask)
    
    # Load coordinate file
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    
    # Load the .npz file
    loaded = np.load('para_sep_fit.npz', allow_pickle=True)
    
    # Convert each dictionary back to a DataFrame
    df_cf_out = pd.DataFrame(loaded['df_cf_out'].item())
    df_mr_out = pd.DataFrame(loaded['df_mr_out'].item())
    df_bw_out = pd.DataFrame(loaded['df_bw_out'].item())
    
    # Plot slopes for all datasets
    plot_slope_maps(df_cf_out, coords, name_prefix='CF')
    plot_slope_maps(df_mr_out, coords, name_prefix='MR')
    plot_slope_maps(df_bw_out, coords, name_prefix='BW')
    


if spike_analysis:
    coords = pd.read_excel('mapping_coordinate.xlsx', sheet_name='coords')
    lsfm_psth_inBF = pd.read_csv('lsfm_psth_para_inBF.csv')
    df_spike = pd.read_csv('spiking_count.csv')
    
    mouseIDs = list(lsfm_psth_inBF['mouseid'])
    sites = list(lsfm_psth_inBF['patch_site'])
    patch_x, patch_y, ortho = [],[],[]
    for i,m in enumerate(mouseIDs):
        site = f'Patch_{sites[i]}'
        patch_x.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].x_A12.item())
        patch_y.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].y_A12.item())
        ortho.append(coords[(coords['mouseid'] == m) & (coords['regions'] == site)].ortho_A1A2.item())
    
    total_spike = list(df_spike['total_spikes'])
    plot_map(patch_x, patch_y, total_spike, saveplot=True, title='Total Spikes', ylabel='Total Spikes (count)', vmax=300)
    
    rate_inbf = list(df_spike['rate_inbf'])
    plot_map(patch_x, patch_y, rate_inbf, saveplot=True, title='Spike Rate, in RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    #regression.regression_test(ortho, rate_inbf)
    fit_x = regression.regression_poly(ortho_x, rate_inbf, degree=1)
    plot_ortho_xx(ortho, rate_inbf, fit_x, saveplot=True, title='Spike Rate, in RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    
    rate_exbf = list(df_spike['rate_exbf'])
    plot_map(patch_x, patch_y, rate_exbf, saveplot=True, title='Spike Rate, out RF', ylabel='Spikes/Stimulus (count)', vmax=2)
    #regression.regression_test(ortho, rate_exbf)
    fit_x = regression.regression_poly(ortho_x, rate_exbf, degree=1)
    plot_ortho_xx(ortho_x, rate_exbf, fit_x, saveplot=True, title='Spike Rate, out RF', ylabel='Spikes/Stimulus (count)', vmax=2)




